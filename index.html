<!DOCTYPE html>
<html>
<head>
    <title>KiwiPathing</title>
    <style>
body {
    background: #000000;
    color: white;
    font-family: Arial;
    margin: 0;
}

h2 {
    text-align: center;
    margin-top: 10px;
}

.mainContainer {
    display: flex;
    height: calc(100vh - 60px);
}

.leftPanel {
    flex: 0 0 auto;
    padding: 10px;
}

.rightPanel {
    width: 320px;
    background: #000000;
    border-left: 2px solid #f2ff00;
    padding: 10px;
    overflow-y: auto;
}

canvas {
    border: 2px solid white;
    display: block;
    margin-top: 10px;
}

.controls {
    margin-bottom: 10px;
}

button, select, input {
    margin: 4px;
    padding: 5px;
}
</style>
</head>
<body>

<h2>KiwiPathing V2.0 (Decode)</h2>

<div class="mainContainer">

    <!-- LEFT SIDE (Canvas + Controls) -->
    <div class="leftPanel">

        <div class="controls">
            <label>Path Type:</label>
            <select id="pathType">
                <option value="line">Straight Line</option>
                <option value="spline">Spline</option>
            </select>

            <label>Final Heading:</label>
            <input type="range" id="headingSlider" min="0" max="360" value="0">
            <span id="headingValue">0°</span>

            <button onclick="exportPath()">Export</button>
            <button onclick="newSegment()">New Segment</button>
            <button onclick="clearAll()">Clear All</button>
        </div>

        <canvas id="fieldCanvas" width="720" height="720"></canvas>

    </div>

    <!-- RIGHT SIDE (Log Panel) -->
    <div class="rightPanel">
        <h3>Segments</h3>
        <div id="segmentPanel"></div>
    </div>

</div>

<script>
const canvas = document.getElementById("fieldCanvas");
const ctx = canvas.getContext("2d");

const FIELD_SIZE = 144;
const SCALE = canvas.width / FIELD_SIZE;

let segments = [];
let currentSegment = null;

const fieldImage = new Image();
fieldImage.src = "field.png";
fieldImage.onload = () => draw();

/* ===============================
   SEGMENT MANAGEMENT
================================= */

function newSegment() {
    const type = document.getElementById("pathType").value;

    currentSegment = {
        type: type,
        points: [],
        heading: 0
    };

    segments.push(currentSegment);
    updateSegmentUI();
}

function clearAll() {
    segments = [];
    currentSegment = null;
    updateSegmentUI();
    draw();
}

/* ===============================
   CANVAS CLICK HANDLING
================================= */

canvas.addEventListener("click", function(event) {

    if (!currentSegment) {
        alert("Click 'New Segment' first!");
        return;
    }

    const rect = canvas.getBoundingClientRect();
    const x = (event.clientX - rect.left) / SCALE;
    const y = FIELD_SIZE - ((event.clientY - rect.top) / SCALE);

    currentSegment.points.push({x, y});

    const neededPoints = currentSegment.type === "line" ? 2 : 3;

    if (currentSegment.points.length >= neededPoints) {
        currentSegment = null; // auto-finish segment
        updateSegmentUI();
    }

    draw();
});

/* ===============================
   DRAWING
================================= */

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(fieldImage, 0, 0, canvas.width, canvas.height);

    segments.forEach(segment => {

        // Draw Points with Numbers
        ctx.fillStyle = "cyan";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        segment.points.forEach((p, pointIndex) => {

            const canvasX = p.x * SCALE;
            const canvasY = (FIELD_SIZE - p.y) * SCALE;

            // Draw dot
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 6, 0, Math.PI*2);
            ctx.fill();

            // Draw number inside dot
            ctx.fillStyle = "black";
            ctx.fillText(pointIndex + 1, canvasX, canvasY);

            ctx.fillStyle = "cyan";
        });

        if (segment.type === "line") {
            drawLineSegment(segment.points);
        } else {
            drawSplineSegment(segment.points);
        }
    });
}

function drawLineSegment(points) {
    if (points.length < 2) return;

    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(points[0].x * SCALE, (FIELD_SIZE - points[0].y) * SCALE);
    ctx.lineTo(points[1].x * SCALE, (FIELD_SIZE - points[1].y) * SCALE);
    ctx.stroke();
}

function drawSplineSegment(points) {
    if (points.length < 2) return;

    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.beginPath();

    const resolution = 20; // higher = smoother

    for (let i = 0; i < points.length - 1; i++) {

        const p0 = points[i - 1] || points[i];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[i + 2] || p2;

        for (let j = 0; j <= resolution; j++) {
            const t = j / resolution;
            const t2 = t * t;
            const t3 = t2 * t;

            const x =
                0.5 * (
                    (2 * p1.x) +
                    (-p0.x + p2.x) * t +
                    (2*p0.x - 5*p1.x + 4*p2.x - p3.x) * t2 +
                    (-p0.x + 3*p1.x - 3*p2.x + p3.x) * t3
                );

            const y =
                0.5 * (
                    (2 * p1.y) +
                    (-p0.y + p2.y) * t +
                    (2*p0.y - 5*p1.y + 4*p2.y - p3.y) * t2 +
                    (-p0.y + 3*p1.y - 3*p2.y + p3.y) * t3
                );

            const canvasX = x * SCALE;
            const canvasY = (FIELD_SIZE - y) * SCALE;

            if (i === 0 && j === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        }
    }

    ctx.stroke();
}
/* ===============================
   LOG UPDATE
================================= */

function updateSegmentUI() {

    const panel = document.getElementById("segmentPanel");
    panel.innerHTML = "";

    segments.forEach((segment, index) => {

        const container = document.createElement("div");
        container.style.background = "#222";
        container.style.border = "1px solid #444";
        container.style.borderRadius = "6px";
        container.style.padding = "8px";
        container.style.marginBottom = "8px";

        const titleRow = document.createElement("div");
        titleRow.style.display = "flex";
        titleRow.style.justifyContent = "space-between";
        titleRow.style.alignItems = "center";

        const title = document.createElement("span");
        title.innerText = `Segment ${index + 1} (${segment.type})`;

        const deleteBtn = document.createElement("button");
        deleteBtn.innerText = "Delete";
        deleteBtn.style.background = "#aa3333";
        deleteBtn.style.color = "white";
        deleteBtn.onclick = function() {
            segments.splice(index, 1);
            updateSegmentUI();
            draw();
        };

        titleRow.appendChild(title);
        titleRow.appendChild(deleteBtn);

        container.appendChild(titleRow);

        // Heading Slider
        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = 0;
        slider.max = 360;
        slider.value = segment.heading;

        const valueLabel = document.createElement("span");
        valueLabel.innerText = segment.heading + "°";

        slider.oninput = function() {
            segment.heading = parseFloat(this.value);
            valueLabel.innerText = this.value + "°";
        };

        container.appendChild(slider);
        container.appendChild(valueLabel);

        panel.appendChild(container);
    });
}

/* ===============================
   EXPORT
================================= */

function exportPath() {

    let text = "";

    segments.forEach((segment, index) => {

        // ========================
        // LINE SEGMENT
        // ========================
        if (segment.type === "line") {

            if (segment.points.length < 2) return;

            const end = segment.points[1];

            text += `// Linear Segment ${index + 1}\n`;
            text += `SpecterDrive.path(${end.x.toFixed(2)}, ${end.y.toFixed(2)}, ${segment.heading}, rC = false)\n\n`;
        }

        // ========================
        // SPLINE SEGMENT
        // ========================
        if (segment.type === "spline") {

            if (segment.points.length < 3) return;

            const resolution = 20;
            const p0 = segment.points[0];
            const p1 = segment.points[1];
            const p2 = segment.points[2];

            text += `// Spline Segment ${index + 1}\n`;
            text += "val path = listOf(\n";

            for (let t = 0; t <= 1; t += 1/resolution) {

                const x =
                    (1 - t)*(1 - t)*p0.x +
                    2*(1 - t)*t*p1.x +
                    t*t*p2.x;

                const y =
                    (1 - t)*(1 - t)*p0.y +
                    2*(1 - t)*t*p1.y +
                    t*t*p2.y;

                const h = (t >= 1) ? segment.heading : "null";

                text += `    PathPoint(${x.toFixed(2)}, ${y.toFixed(2)}, ${h}),\n`;
            }

            text += ")\n\n";
            text += "val pursuit = PurePursuit(path, lookahead = 6.0)\n\n";
            text += "while (opModeIsActive() && !pursuit.isFinished(\n";
            text += "        SpecterDrive.otos.position.x,\n";
            text += "        SpecterDrive.otos.position.y\n";
            text += "    )) {\n";
            text += "    SpecterDrive.followPurePursuit(pursuit)\n";
            text += "}\n\n";
        }

    });

    const blob = new Blob([text], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "specterdrive_path.txt";
    link.click();
}
</script>

</body>
</html>